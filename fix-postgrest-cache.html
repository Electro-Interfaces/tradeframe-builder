<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>üîß PostgREST Cache Fix</title>
    <style>
        body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
        .container { background: #16213e; padding: 20px; margin: 10px 0; border-radius: 8px; border: 1px solid #0f3460; }
        button { background: #0f3460; color: #eee; border: none; padding: 12px 24px; margin: 5px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #1e5f8b; }
        .success { color: #4ade80; font-weight: bold; }
        .error { color: #f87171; font-weight: bold; }
        .warning { color: #fbbf24; font-weight: bold; }
        .info { color: #60a5fa; }
        pre { background: #0f0f23; padding: 15px; border-left: 4px solid #0f3460; overflow-x: auto; }
        h1 { color: #60a5fa; text-align: center; }
        h3 { color: #34d399; border-bottom: 1px solid #0f3460; padding-bottom: 8px; }
    </style>
</head>
<body>
    <h1>üîß PostgREST Schema Cache Fix</h1>
    
    <div class="container">
        <h3>1. üìã Check Table Structure</h3>
        <button onclick="checkTableStructure()">Check equipment_templates</button>
        <div id="structure-result"></div>
    </div>

    <div class="container">
        <h3>2. üîÑ Refresh Schema Cache</h3>
        <button onclick="refreshCache()">Force Schema Refresh</button>
        <div id="cache-result"></div>
    </div>

    <div class="container">
        <h3>3. üß™ Test CREATE Operations</h3>
        <button onclick="testCreate()">Test CREATE with all fields</button>
        <div id="create-result"></div>
    </div>

    <div class="container">
        <h3>4. üéØ Complete Fix</h3>
        <button onclick="runCompleteFix()">üöÄ Run Complete Fix</button>
        <div id="complete-result"></div>
    </div>

    <script>
        const SERVICE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRvaHRyeXp5ZmZjZWJ0eXZreHdoIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1Njg3NTQ0OCwiZXhwIjoyMDcyNDUxNDQ4fQ.kN6uF9YhJzbzu2ugHRQCyzuNOwawsTDtwelGO0uCjyY';
        const URL = 'https://tohtryzyffcebtyvkxwh.supabase.co';

        function log(containerId, msg, type = 'info') {
            const div = document.getElementById(containerId);
            const time = new Date().toLocaleTimeString();
            const className = type;
            div.innerHTML += `<div class="${className}">[${time}] ${msg}</div>\n`;
        }

        async function checkTableStructure() {
            const containerId = 'structure-result';
            document.getElementById(containerId).innerHTML = '';
            log(containerId, 'üîç Checking table structure...', 'info');

            try {
                // Get actual data first
                const dataResponse = await fetch(`${URL}/rest/v1/equipment_templates?limit=2`, {
                    headers: {
                        'apikey': SERVICE_KEY,
                        'Authorization': `Bearer ${SERVICE_KEY}`
                    }
                });

                if (dataResponse.ok) {
                    const data = await dataResponse.json();
                    log(containerId, `‚úÖ Table accessible, ${data.length} records found`, 'success');
                    
                    if (data.length > 0) {
                        const columns = Object.keys(data[0]);
                        log(containerId, `üìã Columns: ${columns.join(', ')}`, 'info');
                        
                        const hasStatus = columns.includes('status');
                        log(containerId, `Status column: ${hasStatus ? '‚úÖ EXISTS' : '‚ùå MISSING'}`, hasStatus ? 'success' : 'error');
                        
                        if (hasStatus) {
                            log(containerId, `Status values: ${data.map(r => r.status).join(', ')}`, 'info');
                        }
                        
                        log(containerId, 'Sample record:', 'info');
                        log(containerId, `<pre>${JSON.stringify(data[0], null, 2)}</pre>`, 'info');
                    }
                } else {
                    log(containerId, `‚ùå Table check failed: ${dataResponse.status}`, 'error');
                }

            } catch (error) {
                log(containerId, `‚ùå Error: ${error.message}`, 'error');
            }
        }

        async function refreshCache() {
            const containerId = 'cache-result';
            document.getElementById(containerId).innerHTML = '';
            log(containerId, 'üîÑ Attempting to refresh PostgREST schema cache...', 'info');

            try {
                // Method 1: ANALYZE table
                log(containerId, '1Ô∏è‚É£ Running ANALYZE on equipment_templates...', 'info');
                
                const analyzeSQL = "ANALYZE equipment_templates;";
                const analyzeResponse = await fetch(`${URL}/rest/v1/rpc/exec_sql`, {
                    method: 'POST',
                    headers: {
                        'apikey': SERVICE_KEY,
                        'Authorization': `Bearer ${SERVICE_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sql: analyzeSQL })
                });

                if (!analyzeResponse.ok) {
                    log(containerId, '‚ö†Ô∏è exec_sql RPC not available, trying alternative...', 'warning');
                    
                    // Method 2: Force reload by querying different endpoints
                    log(containerId, '2Ô∏è‚É£ Force reloading via different endpoints...', 'info');
                    
                    const endpoints = [
                        '/?columns=*',
                        '/equipment_templates?limit=0',
                        '/equipment_templates?select=*&limit=1'
                    ];
                    
                    for (const endpoint of endpoints) {
                        const response = await fetch(`${URL}/rest/v1${endpoint}`, {
                            headers: {
                                'apikey': SERVICE_KEY,
                                'Authorization': `Bearer ${SERVICE_KEY}`,
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            }
                        });
                        log(containerId, `   ${endpoint}: ${response.status}`, response.ok ? 'success' : 'warning');
                    }
                }

                // Method 3: Wait for cache timeout (PostgREST typically caches for 60 seconds)
                log(containerId, '3Ô∏è‚É£ Waiting for natural cache refresh (5 seconds)...', 'info');
                await new Promise(resolve => setTimeout(resolve, 5000));
                
                log(containerId, '‚úÖ Cache refresh attempts completed', 'success');
                log(containerId, 'üí° If CREATE still fails, PostgREST may need manual restart', 'warning');

            } catch (error) {
                log(containerId, `‚ùå Cache refresh failed: ${error.message}`, 'error');
            }
        }

        async function testCreate() {
            const containerId = 'create-result';
            document.getElementById(containerId).innerHTML = '';
            log(containerId, 'üß™ Testing CREATE operation...', 'info');

            const testId = 'cache-fix-' + Date.now();

            try {
                // Test with all required fields explicitly
                const payload = {
                    id: testId,
                    name: 'Cache Fix Test',
                    technical_code: 'CACHE_FIX_' + Date.now(),
                    system_type: 'test',
                    status: true,
                    description: 'Test record for schema cache fix'
                };

                log(containerId, 'Payload:', 'info');
                log(containerId, `<pre>${JSON.stringify(payload, null, 2)}</pre>`, 'info');

                const response = await fetch(`${URL}/rest/v1/equipment_templates`, {
                    method: 'POST',
                    headers: {
                        'apikey': SERVICE_KEY,
                        'Authorization': `Bearer ${SERVICE_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=representation',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify(payload)
                });

                log(containerId, `Response: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');

                if (response.ok) {
                    const result = await response.json();
                    log(containerId, 'üéâ CREATE SUCCESS!', 'success');
                    log(containerId, `Created: ${result[0]?.name || 'Record created'}`, 'success');
                    
                    // Cleanup
                    setTimeout(async () => {
                        try {
                            await fetch(`${URL}/rest/v1/equipment_templates?id=eq.${testId}`, {
                                method: 'DELETE',
                                headers: {
                                    'apikey': SERVICE_KEY,
                                    'Authorization': `Bearer ${SERVICE_KEY}`
                                }
                            });
                            log(containerId, 'üßπ Test record cleaned up', 'info');
                        } catch (e) {
                            log(containerId, '‚ö†Ô∏è Cleanup failed (not critical)', 'warning');
                        }
                    }, 2000);
                    
                } else {
                    const errorText = await response.text();
                    log(containerId, '‚ùå CREATE FAILED', 'error');
                    log(containerId, `Error: ${errorText}`, 'error');
                    
                    if (errorText.includes('schema cache')) {
                        log(containerId, 'üîß This is still a schema cache issue', 'warning');
                        log(containerId, 'üí° Try running the complete fix or wait longer', 'warning');
                    }
                }

            } catch (error) {
                log(containerId, `‚ùå CREATE test failed: ${error.message}`, 'error');
            }
        }

        async function runCompleteFix() {
            const containerId = 'complete-result';
            document.getElementById(containerId).innerHTML = '';
            log(containerId, 'üöÄ Running complete schema cache fix...', 'info');

            // Step 1: Check current state
            log(containerId, '1Ô∏è‚É£ Checking current state...', 'info');
            await checkTableStructure();
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Step 2: Force cache refresh
            log(containerId, '2Ô∏è‚É£ Refreshing cache...', 'info');
            await refreshCache();
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Step 3: Test CREATE
            log(containerId, '3Ô∏è‚É£ Testing CREATE...', 'info');
            await testCreate();
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Step 4: Final verification
            log(containerId, '4Ô∏è‚É£ Final verification...', 'info');
            try {
                const verifyResponse = await fetch(`${URL}/rest/v1/equipment_templates?limit=3&select=id,name,status`, {
                    headers: {
                        'apikey': SERVICE_KEY,
                        'Authorization': `Bearer ${SERVICE_KEY}`
                    }
                });

                if (verifyResponse.ok) {
                    const data = await verifyResponse.json();
                    log(containerId, `‚úÖ Final verification: ${data.length} records accessible`, 'success');
                    log(containerId, 'üéâ COMPLETE FIX FINISHED!', 'success');
                    
                    if (data.some(r => r.status !== undefined)) {
                        log(containerId, '‚úÖ Status column is working in SELECT operations', 'success');
                    }
                    
                    log(containerId, '\nüîß NEXT STEPS:', 'info');
                    log(containerId, '‚Ä¢ Try CREATE operation in your main application', 'info');
                    log(containerId, '‚Ä¢ If still failing, restart PostgREST service in Supabase', 'info');
                    log(containerId, '‚Ä¢ Update project files with Service Role Key', 'info');
                    
                } else {
                    log(containerId, '‚ùå Final verification failed', 'error');
                }
                
            } catch (error) {
                log(containerId, `‚ùå Final verification error: ${error.message}`, 'error');
            }
        }

        // Auto-start
        setTimeout(() => {
            runCompleteFix();
        }, 1000);
    </script>
</body>
</html>