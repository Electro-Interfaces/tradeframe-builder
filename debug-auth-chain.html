<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Auth Chain</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .step { margin: 10px 0; padding: 10px; border: 1px solid #ddd; }
        .success { background: #d4edda; }
        .error { background: #f8d7da; }
        .info { background: #d1ecf1; }
        pre { background: #f8f9fa; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>Отладка цепочки авторизации</h1>

    <div>
        <input type="email" id="email" placeholder="Email (l@me.com)" value="l@me.com">
        <input type="password" id="password" placeholder="Password (qwerty)" value="qwerty">
        <button onclick="debugAuth()">Проследить авторизацию</button>
    </div>

    <div id="steps"></div>

    <script>
        class AuthServiceDebug {
            constructor() {
                this.SUPABASE_URL = 'https://ssvazdgnmatbdynkhkqo.supabase.co';
                this.SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNzdmF6ZGdubWF0YmR5bmtoa3FvIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NzM0MzgzNCwiZXhwIjoyMDcyOTE5ODM0fQ.Gen-PI-vDkKjskpIvJNcQw0Uj3d0zGXB98zIxNK6di0';
                this.steps = [];
            }

            log(step, status, data) {
                this.steps.push({ step, status, data, timestamp: new Date().toISOString() });
                this.renderSteps();
            }

            renderSteps() {
                const container = document.getElementById('steps');
                container.innerHTML = this.steps.map(step =>
                    `<div class="step ${step.status}">
                        <strong>${step.step}</strong> - ${step.status}
                        <br><small>${step.timestamp}</small>
                        <pre>${JSON.stringify(step.data, null, 2)}</pre>
                    </div>`
                ).join('');
            }

            async makeRequest(endpoint, options = {}) {
                const url = `${this.SUPABASE_URL}/rest/v1/${endpoint}`;

                this.log('HTTP Request', 'info', { url, options });

                const response = await fetch(url, {
                    ...options,
                    headers: {
                        'apikey': this.SUPABASE_KEY,
                        'Authorization': `Bearer ${this.SUPABASE_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=representation',
                        ...options.headers,
                    },
                });

                const result = await response.json();

                this.log('HTTP Response', response.ok ? 'success' : 'error', {
                    status: response.status,
                    data: result
                });

                return result;
            }

            async getUserByEmail(email) {
                this.log('Шаг 1: Поиск пользователя', 'info', { email });

                try {
                    // Тестируем оба варианта поиска
                    const exactSearch = await this.makeRequest(
                        `users?email=eq.${encodeURIComponent(email)}&deleted_at=is.null&limit=1`
                    );

                    this.log('Точный поиск (eq)', exactSearch.length > 0 ? 'success' : 'error', {
                        query: `email=eq.${email}`,
                        found: exactSearch.length,
                        users: exactSearch
                    });

                    const ilikeSearch = await this.makeRequest(
                        `users?email=ilike.${encodeURIComponent(email)}&deleted_at=is.null&limit=1`
                    );

                    this.log('Поиск ilike', ilikeSearch.length > 0 ? 'success' : 'error', {
                        query: `email=ilike.${email}`,
                        found: ilikeSearch.length,
                        users: ilikeSearch
                    });

                    return ilikeSearch.length > 0 ? ilikeSearch[0] : null;
                } catch (error) {
                    this.log('Ошибка поиска пользователя', 'error', { error: error.message });
                    return null;
                }
            }

            base64ToArrayBuffer(base64) {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes.buffer;
            }

            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            async verifyPassword(user, password) {
                this.log('Шаг 2: Проверка пароля', 'info', {
                    userEmail: user.email,
                    hasSalt: !!user.pwd_salt,
                    hasHash: !!user.pwd_hash,
                    saltLength: user.pwd_salt?.length,
                    hashLength: user.pwd_hash?.length
                });

                if (!password || password.length < 3) {
                    this.log('Пароль слишком короткий', 'error', { passwordLength: password.length });
                    return false;
                }

                if (!user.pwd_salt || !user.pwd_hash) {
                    this.log('Нет данных пароля у пользователя', 'error', {
                        hasSalt: !!user.pwd_salt,
                        hasHash: !!user.pwd_hash
                    });
                    return false;
                }

                // Проверяем доступность Web Crypto API
                if (!crypto || !crypto.subtle) {
                    this.log('Web Crypto API недоступен', 'error', {
                        protocol: window.location.protocol,
                        hostname: window.location.hostname,
                        isSecure: window.isSecureContext,
                        cryptoAvailable: !!crypto,
                        subtleAvailable: !!(crypto && crypto.subtle)
                    });
                    return this.verifyPasswordFallback(user, password);
                }

                try {
                    const encoder = new TextEncoder();
                    const passwordBytes = encoder.encode(password);
                    const saltBytes = this.base64ToArrayBuffer(user.pwd_salt);

                    this.log('Подготовка к PBKDF2', 'info', {
                        passwordLength: passwordBytes.length,
                        saltLength: saltBytes.byteLength,
                        iterations: 100000
                    });

                    const keyMaterial = await crypto.subtle.importKey(
                        'raw',
                        passwordBytes,
                        { name: 'PBKDF2' },
                        false,
                        ['deriveBits']
                    );

                    const hashBuffer = await crypto.subtle.deriveBits(
                        {
                            name: 'PBKDF2',
                            salt: saltBytes,
                            iterations: 100000,
                            hash: 'SHA-256'
                        },
                        keyMaterial,
                        32 * 8
                    );

                    const computedHash = this.arrayBufferToBase64(hashBuffer);
                    const isValid = computedHash === user.pwd_hash;

                    this.log('Результат PBKDF2', isValid ? 'success' : 'error', {
                        computedHash: computedHash.substring(0, 10) + '...',
                        storedHash: user.pwd_hash.substring(0, 10) + '...',
                        match: isValid,
                        computedHashFull: computedHash,
                        storedHashFull: user.pwd_hash
                    });

                    return isValid;
                } catch (error) {
                    this.log('Ошибка PBKDF2', 'error', { error: error.message });
                    return this.verifyPasswordFallback(user, password);
                }
            }

            verifyPasswordFallback(user, password) {
                this.log('Шаг 3: Fallback проверка', 'info', {});

                // Проверка тестового пользователя
                if (user.email === 'u@me.com' && password === '123456') {
                    this.log('Тестовый пользователь u@me.com', 'success', {});
                    return true;
                }

                try {
                    if (user.pwd_hash && user.pwd_salt) {
                        const encoder = new TextEncoder();
                        const passwordWithSalt = password + user.pwd_salt;
                        const hash = btoa(passwordWithSalt);
                        const isValid = hash === user.pwd_hash;

                        this.log('Fallback хеширование', isValid ? 'success' : 'error', {
                            passwordWithSalt: passwordWithSalt.substring(0, 20) + '...',
                            computedHash: hash.substring(0, 10) + '...',
                            storedHash: user.pwd_hash.substring(0, 10) + '...',
                            match: isValid
                        });

                        return isValid;
                    }

                    this.log('Нет данных для fallback', 'error', {});
                    return false;
                } catch (error) {
                    this.log('Ошибка fallback', 'error', { error: error.message });
                    return false;
                }
            }

            async authenticate(email, password) {
                this.steps = []; // Очищаем предыдущие шаги
                this.log('Начало авторизации', 'info', { email, passwordLength: password.length });

                try {
                    const dbUser = await this.getUserByEmail(email);
                    if (!dbUser) {
                        this.log('Пользователь не найден', 'error', {});
                        return null;
                    }

                    const isValidPassword = await this.verifyPassword(dbUser, password);
                    if (!isValidPassword) {
                        this.log('Неверный пароль', 'error', {});
                        return null;
                    }

                    this.log('Авторизация успешна', 'success', { userId: dbUser.id });
                    return dbUser;
                } catch (error) {
                    this.log('Ошибка авторизации', 'error', { error: error.message });
                    return null;
                }
            }
        }

        const authDebug = new AuthServiceDebug();

        async function debugAuth() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;

            await authDebug.authenticate(email, password);
        }
    </script>
</body>
</html>